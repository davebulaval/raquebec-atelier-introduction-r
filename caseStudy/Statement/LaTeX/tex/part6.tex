Quand bien même que la génération de nombres aléatoires ai déjà été abordée à la \autoref{sec:statsTools}, il serait injuste de s'imaginer que les capacités de R s'arrêtent là. R est un excellent langage pour faire des simulations complexes. L'estimation par simulation sera souvent un excellent moyen pour évaluer le comportement d'un phénomène difficilement quantifiable de manière déterministe. \\

La première fonction à connaître lorsque nous abordons une analyse de ce genre est la fonction \texttt{sample} \cite{Rfunction:sample}. Cette dernière sera utile dans les cas où nous cherchons à faire une pige aléatoire de taille quelconque (\texttt{size}) sur un ensemble de valeurs contenues dans un vecteur. Il sera possible de préciser si nous voulons faire une pige avec ou sans remise avec l'argument \texttt{replace} ainsi que la probabilité de survenance de chaque élément grâce à l'argument \texttt{prob}. Un aspect fort intéressant de cette fonction est sa capacité de faire des piges sur des valeurs textuelles. Le \autoref{src:sample} illustre un exemple simplifié de l'utilisation de la fonction \texttt{sample}. Lors du deuxième appel de la fonction, nous remarquons la génération de valeurs beaucoup plus élevées par rapport au premier appel. Toutefois, la seule différence a été de modifier la valeur de l'argument \texttt{prob} pour y assigner le poids relatif de l'altitude sur l'ensemble des altitudes favorisant ainsi les valeurs extrêmes positives. Le troisième appel expose, quant à lui, la capacité de travailler avec un vecteur de valeurs textuelles. \\

\begin{lstlisting}[caption = Pige aléatoire sur support vectoriel,label=src:sample]
> altitude <- as.numeric(paste(airportsCanada$altitude))
> sample(altitude,size = 10, replace = TRUE)
 [1] 1408  713  210 1912  703  602 3903  925   39  152
> probs <- pmax(0,altitude)/sum(pmax(0,altitude))
> sample(altitude,size = 10, replace = TRUE,prob = probs)
 [1] 1023 3126 2364 1211 1000 1892  951  770 1653 2567
> sample(unique(as.character(paste(airportsCanada$name))),size = 10,replace = FALSE)
 [1] "Kangiqsujuaq (Wakeham Bay) Airport"
 [2] "St Jean Airport"                   
 [3] "Fort Frances Municipal Airport"    
 [4] "South Indian Lake Airport"         
 [5] "Prince George Airport"             
 [6] "Pembroke Airport"                  
 [7] "Kugluktuk Airport"                 
 [8] "Haines Junction Airport"           
 [9] "Edson Airport"                     
[10] "Eastmain River Airport"  
\end{lstlisting}

En inspectant le \autoref{src:CaseStudyDevQ6}, nous constatons la structure fonctionnelle et imbriquée du processus emprunté. Il sera fortement conseillé de procéder ainsi pour différentes raisons:

\begin{itemize}
	\item Augmenter la clarté du processus de simulation
	\item Faciliter le débogage lors du développement
	\item Possibilité de facilement ajouter et retirer des blocs au casse-tête de simulation
	\item Identification simplifiée des parties limitantes et coûteuses en temps de calcul pour des fins d'optimisation
	\item Permettre la production d'une nouvelle itération par l'appel d'une fonction mère ne possédant idéalement aucun argument
\end{itemize}

Ce ne sera qu'en présence de cette structure que la fonction \texttt{replicate} prendra tout son sens. À l'aide de cette fonction, nous pourrons commodément contrôler le nombre de répliques effectuées. Dans le \autoref{src:replicate}, nous avons justement pris cette fonctionnalité pour reproduire à 6 reprises la génération de nombres aléatoires suivant une loi $Norm(\mu := 3, \sigma := 4)$.

\begin{lstlisting}[caption = Replication d'une analyse par simulation,label=src:replicate]
fsimul <- function() qnorm(runif(100),3,4)
results <- replicate(6,fsimul())
g <- rep(c("a", "b","c","d","e","f"), each = 100)
#install.packages("lattice")
library(lattice)
histogram(~ as.vector(results) | g,xlab = "Results",ylab = "Frequency") 
\end{lstlisting}

\addPicture{1}{0.5}{replicate}{Comparaison des résultats de simulation obtenus avec 6 réplicats}{replicate}

\begin{moreInfo}{Une "Poisson" dans une pisciculture...}
	La distribution Poisson sera souvent à la base des processus de simulation en raison de ses propriétés particulières. Nous parlerons souvent du fait que cette loi ne possède pas de mémoire ce qui implique que le nombre de succès observés sur différents intervalles seront indépendants. Nous pouvons aussi mentionner que la somme des variables aléatoires suivant des lois Poisson indépendantes de paramètres $\lambda_1$ et $\lambda_2$ suivra à son tour une loi de Poisson de paramètre $\lambda_1 + \lambda_2$. \\
	\url{https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/course-notes/MIT6_262S11_chap02.pdf} \\
	\url{https://fr.wikipedia.org/wiki/Loi_de_Poisson}
\end{moreInfo}