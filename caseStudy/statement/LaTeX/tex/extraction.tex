\subsection{Extraction}
	\label{subsec:extraction}

Les données d'OpenFlights possèdent l'avantage d'être téléchargeables directement via le web pour les rendre disponibles à notre environnement de travail. Pour ce faire, nous mettons à profit la fonction \texttt{read.csv} \cite{Rfunction:read.csv}. Bien que le nom de la fonction indique qu'elle permet de lire un fichier présenté dans un format \emph{comma-separated values} \texttt{.csv}, nous pouvons tout aussi bien utiliser cette fonction pour extraire des fichiers \texttt{.dat}. La différence principale entre ces deux types de fichiers est que les fichiers \texttt{.csv} utilisent un caractère d'encadrement des informations qui se trouve à être les doubles guillemets dans la majorité des cas. De plus, les fichiers \texttt{.csv} utiliseront, comme leur nom l'indique, la virgule à titre de séparateur bien que celle-ci puisse être modifiée pour un autre symbole.\cite{CSVDAT} Lorsque nous jetons un coup d'oeil à la structure des fichiers \texttt{.dat} disponibles à la \autoref{fig:rawAirports}, nous constatons que ceux-ci respectent les deux caractéristiques que nous venons de mentionner, rendant ainsi l'utilisation de la fonction \texttt{read.csv} autant naturelle. \\

\addPicture{1}{1}{rawAirports}{Extrait du fichier airports.dat}{rawAirports} 

Dans la même figure, on constate aussi l'absence d'une ligne servant à présenter les en-têtes de colonnes. Ceci pourra dans certains cas vous jouer de mauvais tours en ignorant la première ligne de données ou encore considérer les titres comme étant des entrées en soi. \footnote{La deuxième situation étant bien moins dramatique et plus facilement identifiable.} Bien qu'il serait possible de travailler avec des données sans en-tête, il s'agit ici d'une très mauvaise pratique. Pour remédier à la situation, nous assignerons donc des noms aux colonnes grâce à la méthode \texttt{colnames} de la classe \texttt{data.frame} en lui passant un vecteur contenant les noms désirés. \\

\begin{moreInfo}{Pourquoi ne pas avoir choisi la pilule rouge?!}
	Vous vous demandez probablement pourquoi R utilise un \texttt{data.frame} plutôt qu'un \texttt{array} ou une \texttt{matrix} pour contenir les données. Tout d'abord, le conteneur le plus simple de R est le \texttt{vector}. De cette classe, nous aurons le \texttt{array} qui est une spécialisation de \texttt{vector} possèdant un attribut \texttt{dim}. La classe \texttt{matrix} sera à son tour une spécialisation de la classe \texttt{array} qui ne pourra avoir que deux dimensions (lignes et colonnes). Comme nous pouvons le voir, tous ces conteneurs possèdent des caractéristiques intéressantes d'un point de vue mathématique, mais ils souffriront tous de la même lacune; ils ne peuvent contenir que des éléments ayant le même mode. La classe \texttt{data.frame} contournera ce problème en héritant plutôt de la classe \texttt{list}. Elle conservera tout de même les propriétés mathématiques des 3 autres conteneurs précédents en utilisant la technique de la composition. En d'autres mots, un \texttt{data.frame} n'est rien d'autre qu'une \texttt{list} de \texttt{vector}. \\
	\url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/vector.html} \\
	\url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/array.html} \\
	\url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/matrix.html} \\
	\url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/data.frame.html} 
\end{moreInfo}

Par défaut, lors de l'importation, la fonction \texttt{read.csv} retournera un \texttt{data.frame} en transformant les chaînes de caractères sous la forme de facteurs (\texttt{factors}). Cette action sera complètement transparente à l'utilisateur et l'affichage des variables ne sera pas impacté. Ceci s'explique par le fait que R créera des formats d'affichage qui associeront à chaque facteur une valeur unique correspondante. Le seul impact réel réside plutôt dans la possibilité d'utiliser des fonctions à caractères mathématiques sur les données, peu importe si ces dernières sont numériques ou non. Parmi ce genre de fonctions, nous pouvons penser à des fonctions d'agrégation (\emph{clustering}) ou tout simplement à l'utilisation de la fonction \texttt{summary} \cite{Rfunction:summary} permettant d'afficher des informations génériques sur le contenu d'un objet. Il est important de comprendre que les données ne sont toutefois plus représentées comme des chaînes de caractères, mais bien par un facteur référant à la valeur textuelle correspondante. \\

La manière de représenter des valeurs manquantes variera souvent d'une base de données à une autre. Une fonctionnalité très intéressante de la fonction \texttt{read.csv} est de pouvoir automatiquement convertir ces chaînes de caractères symboliques en \texttt{NA} ayant une signification particulière dans R. Dans le cas présent, les valeurs manquantes sont représentées par \text{\textbackslash \textbackslash n} ou \text{" "} correspondant respectivement à un retour de chariot et à un espace vide. Il suffit donc de passer cette liste de valeurs à l'argument \texttt{na.strings}. \\

\begin{moreInfo}{\texttt{read.csv}}
	La fonction \texttt{read.csv} renferme plusieurs autres arguments très intéressants dans des situations plus pointues. Pour en savoir plus, nous vous invitons à consulter la documentation officielle. \\
	\url{https://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html}
\end{moreInfo}

Comme nous venons de le démontrer, l'extraction des données peut facilement devenir une tâche ingrate si nous n'avons aucune connaissance sur la manière dont l'information y a été entreposée. La règle d'or est donc de toujours avoir une idée globale de ce que nous cherchons à importer afin de bien paramétrer les fonctions. Si nous assemblons les différents aspects que nous venons d'aborder, nous aboutissons donc au code suivant:
\begin{lstlisting}[caption = Extraction des données,label=src:Extraction]
	airports <- read.csv("https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat", header = FALSE, na.strings=c('\\N',''))
\end{lstlisting}