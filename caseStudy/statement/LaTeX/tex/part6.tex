Quand bien même que la génération de nombres aléatoires ai déjà été abordée à la \autoref{sec:statsTools}, il serait injuste de s'imaginer que les capacités de R s'arrêtent là. R est un excellent langage pour faire des simulations complexes. L'estimation par simulation sera souvent un excellent moyen pour évaluer le comportement d'un phénomène difficilement quantifiable de manière déterministe. \\

La première fonction à connaître lorsque nous abordons une analyse de ce genre est la fonction \texttt{sample} \cite{Rfunction:sample}. Cette dernière sera utile dans les cas où nous cherchons à faire une pige aléatoire de taille quelconque (\texttt{size}) sur un ensemble de valeurs contenues dans un vecteur. Il sera possible de préciser si nous voulons faire une pige avec ou sans remise avec l'argument \texttt{replace} ainsi que la probabilité de survenance de chaque élément grâce à l'argument \texttt{prob}. Un aspect fort intéressant de cette fonction est sa capacité de faire des piges sur des valeurs textuelles. Le \autoref{src:sample} illustre un exemple simplifié de l'utilisation de la fonction \texttt{sample}. Lors du deuxième appel de la fonction, nous remarquons la génération de valeurs beaucoup plus élevées par rapport au premier appel. Toutefois, la seule différence a été de modifier la valeur de l'argument \texttt{prob} pour y assigner le poids relatif de l'altitude sur l'ensemble des altitudes favorisant ainsi les valeurs extrêmes positives. Le troisième appel expose, quant à lui, la capacité de travailler avec un vecteur de valeurs textuelles. \\

\begin{lstlisting}[caption = Pige aléatoire sur support vectoriel,label=src:sample]
> altitude <- as.numeric(paste(airportsCanada$altitude))
> sample(altitude,size = 10, replace = TRUE)
 [1] 1408  713  210 1912  703  602 3903  925   39  152
> probs <- pmax(0,altitude)/sum(pmax(0,altitude))
> sample(altitude,size = 10, replace = TRUE,prob = probs)
 [1] 1023 3126 2364 1211 1000 1892  951  770 1653 2567
> sample(unique(as.character(paste(airportsCanada$name))),size = 10,replace = FALSE)
 [1] "Kangiqsujuaq (Wakeham Bay) Airport"
 [2] "St Jean Airport"                   
 [3] "Fort Frances Municipal Airport"    
 [4] "South Indian Lake Airport"         
 [5] "Prince George Airport"             
 [6] "Pembroke Airport"                  
 [7] "Kugluktuk Airport"                 
 [8] "Haines Junction Airport"           
 [9] "Edson Airport"                     
[10] "Eastmain River Airport"  
\end{lstlisting}

En inspectant le \autoref{src:caseStudy6}, nous constatons la structure fonctionnelle et imbriquée du processus emprunté. Il sera fortement conseillé de procéder ainsi pour différentes raisons:

\begin{itemize}
	\item Augmenter la clarté du processus de simulation
	\item Faciliter le débogage lors du développement
	\item Possibilité de facilement ajouter et retirer des blocs au casse-tête de simulation
	\item Identification simplifiée des parties limitantes et coûteuses en temps de calcul pour des fins d'optimisation
	\item Permettre la production d'une nouvelle itération par l'appel d'une fonction mère ne possédant idéalement aucun argument
\end{itemize}

Ce ne sera qu'en présence de cette structure que la fonction \texttt{replicate} prendra tout son sens. À l'aide de cette fonction, nous pourrons commodément contrôler le nombre de répliques effectuées. Dans le \autoref{src:replicate}, nous avons justement pris cette fonctionnalité pour reproduire à 6 reprises la génération de nombres aléatoires suivant une loi $Norm(\mu := 3, \sigma := 4)$.

\begin{lstlisting}[caption = Replication d'une analyse par simulation,label=src:replicate]
fsimul <- function() qnorm(runif(100),3,4)
results <- replicate(6,fsimul())
g <- rep(c("a", "b","c","d","e","f"), each = 100)
#install.packages("lattice")
library(lattice)
histogram(~ as.vector(results) | g,xlab = "Results",ylab = "Frequency") 
\end{lstlisting}

\addPicture{1}{0.5}{replicate}{Comparaison des résultats de simulation obtenus avec 6 réplicats}{replicate}

\begin{moreInfo}{Une "Poisson" dans une pisciculture...}
	La distribution Poisson sera souvent à la base des processus de simulation en raison de ses propriétés particulières. Nous parlerons souvent du fait que cette loi ne possède pas de mémoire ce qui implique que le nombre de succès observés sur différents intervalles seront indépendants. Nous pouvons aussi mentionner que la somme des variables aléatoires suivant des lois Poisson indépendantes de paramètres $\lambda_1$ et $\lambda_2$ suivra à son tour une loi de Poisson de paramètre $\lambda_1 + \lambda_2$. \\
	\url{https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-262-discrete-stochastic-processes-spring-2011/course-notes/MIT6_262S11_chap02.pdf} \\
	\url{https://fr.wikipedia.org/wiki/Loi_de_Poisson}
\end{moreInfo}

Dans le contexte de l'étude, ces notions de simulation nous ont permis de procéder à une analyse de la compétitivité de notre nouvelle tarification. À partir du nombre de colis moyen observé pour chacun des mois au cours des trois dernières années (\autoref{tab:lambdaPois}), nous serons en mesure de pouvoir générer une observation qui représentera le nombre de colis qui seront postés au cours de la prochaine année. \\

\begin{table}
	\centering
	\begin{tabular}{cc}
		Mois & Nombre de colis \\
		\hline
		Janvier & 2000 \\
		Février & 1700 \\
		Mars & 1500 \\
		Avril & 1350 \\
		Mai & 1600 \\
		Juin & 1650 \\
		Juillet & 1750 \\
		Août & 2000 \\
		Septembre & 2300 \\
		Octobre & 2425 \\
		Novembre & 2500 \\
		Décembre & 3500 \\
		\hline
		Total & 24275
	\end{tabular}
	\caption{Moyenne trois ans du nombre de colis postés pour chacun des mois de l'année}
	\label{tab:lambdaPois}
\end{table}

Nous ferons ici appel au fait que la moyenne d'une loi de poisson de paramètre $\lambda$ correspond tout simplement au paramètre lui-même et qu'une addition de lois de poisson indépendantes est équivalente à une loi de poisson dont le paramètre $\lambda$ sera en fait l'addition des paramètres de chacune des lois qui la constitue. Cela revient donc à dire que nous pourrons modéliser le nombre de colis postés au cours d'une année grâce à une $Pois(\lambda = 24275)$. \\


%
%> nsim <- 1
%> simulResults <- replicate(nsim, simulOverall(),simplify = FALSE)
%> (marketShareSales <- sapply(1:nsim,function(x) 
%+   sum(as.numeric(simulResults[[x]][6,]))/length(simulResults[[x]][6,])))
%[1] 0.3143401
%> (ownRevenus <- sum(as.numeric(simulResults[[1]][4,])*
%+                      as.numeric(simulResults[[1]][6,]),na.rm = TRUE))
%[1] 353490.7
%> (compRevenus <- sum(as.numeric(simulResults[[1]][5,])*
%+                       (1-as.numeric(simulResults[[1]][6,])),na.rm = TRUE))
%[1] 1438990
%> (marketShareRevenus <- ownRevenus/(ownRevenus+compRevenus))
%[1] 0.1972075
%> 
%> arrivalSales <- as.character(simulResults[[1]][1,simulResults[[1]][6,]==1]) 
%> distanceSales <- as.numeric(simulResults[[1]][2,simulResults[[1]][6,]==1])
%> weightSales <- as.numeric(simulResults[[1]][3,simulResults[[1]][6,]==1])
%> 
%> arrivalComp <- as.character(simulResults[[1]][1,simulResults[[1]][6,]==0]) 
%> distanceComp <- as.numeric(simulResults[[1]][2,simulResults[[1]][6,]==0])
%> weightComp <- as.numeric(simulResults[[1]][3,simulResults[[1]][6,]==0])
%> 
%> # Representation of the result
%> table(arrivalSales)
%arrivalSales
% YEG  YHZ  YOW  YQB  YVR  YWG  YYC  YYZ  YZV 
% 555  261 1291  270  847  430  651 3018  279 
%> mean(distanceSales)
%[1] 1281.691
%> table(arrivalComp)
%arrivalComp
% YBC  YBG  YEG  YFC  YGL  YGW  YHZ  YMT  YOW  YQB  YQM  YSJ  YTZ  YUY  YVO 
% 320  230 1708  207  150  355  968  190  114  850  377  167  483  220  389 
% YVP  YVR  YWG  YWK  YYC  YYG  YYT  YYY  YYZ  YZV  ZBF 
% 540 2534 1429  826 2105  251  841  429    1  825   73 
%> mean(distanceComp)
%[1] 1831.261